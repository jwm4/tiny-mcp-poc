# nps_mcp_server.py
# MCP server for the National Park Service APIs
# Enhanced with HTTP server support for remote testing
# Mostly generated by Cursor using Claude 4 Sonnet.

"""MCP server for the National Park Service APIs.

These APIs are documented at https://www.nps.gov/subjects/developer/api-documentation.htm

The NPS API provides access to:
- Parks: Location, contact, operating hours, and entrance fee information
- Alerts: Announcements about hazardous or changing conditions
- Campgrounds: Location, contact, operating hours, site amenities, and fee information
- Events: Date, time, fee, and description of events in national parks
- Visitor Centers: Location, contact, and operating hours information
- News Releases: Title, abstract, and links to park news releases
- Articles: Titles, images, and descriptions of shared content articles

Authentication: Requires an API key passed via X-Api-Key header or api_key parameter
Rate Limits: 1,000 requests per hour per API key
"""

from typing import Optional
import httpx
from fastmcp import FastMCP
import os
import argparse
import json
import logging

# Logger will be configured after parsing command line arguments
logger = None

def get_logger():
    """Get the logger, creating a default one if not configured yet."""
    global logger
    if logger is None:
        # Create a default logger with WARNING level if not configured
        logger = configure_logging("WARNING")
    return logger

# Initialize FastMCP server
# The name "nps" is how this server will be identified by clients
mcp = FastMCP("nps")

# Constants for the National Park Service API
NPS_API_BASE = "https://developer.nps.gov/api/v1"
USER_AGENT = "nps-mcp-server/1.0 (contact@example.com)"

# Get API key from environment variable
def configure_logging(log_level: str) -> logging.Logger:
    """Configure logging with the specified level."""
    global logger
    
    # Convert string level to logging constant
    numeric_level = getattr(logging, log_level.upper())
    
    # Configure root logger at WARNING level to suppress dependency logs
    logging.basicConfig(
        level=logging.WARNING,  # Keep dependencies quiet
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[
            logging.StreamHandler(),  # Console output
            logging.FileHandler("nps_mcp_server.log")  # File output
        ],
        force=True  # Override any existing configuration
    )
    
    # Set our specific logger to the requested level
    logger = logging.getLogger(__name__)
    logger.setLevel(numeric_level)
    
    # Also set the "nps" logger (from FastMCP) to the requested level if needed
    nps_logger = logging.getLogger("nps")
    nps_logger.setLevel(numeric_level)
    
    # Debug info for troubleshooting (can be removed later)
    if log_level == "DEBUG":
        print(f"Debug: Logger '{__name__}' set to {log_level} level")
        print("Debug: Dependency loggers remain at WARNING level")
    
    return logger

def mask_sensitive_headers(headers: dict) -> dict:
    """Create a copy of headers with sensitive values masked for logging."""
    masked_headers = headers.copy()
    sensitive_keys = ["X-Api-Key", "x-api-key", "Authorization", "authorization"]
    
    for key in masked_headers:
        if key in sensitive_keys:
            value = masked_headers[key]
            if len(value) > 8:
                # Show first 4 and last 4 characters with asterisks in between
                masked_headers[key] = f"{value[:4]}***{value[-4:]}"
            else:
                # For shorter values, just show asterisks
                masked_headers[key] = "***"
    
    return masked_headers

def get_api_key() -> str:
    """Get NPS API key from environment variable."""
    api_key = os.getenv("NPS_API_KEY")
    if not api_key:
        return "DEMO_KEY"  # NPS allows limited use with DEMO_KEY
    return api_key

@mcp.tool()
async def search_parks(
    state_code: Optional[str] = None, 
    park_code: Optional[str] = None,
    query: Optional[str] = None,
    limit: int = 10
) -> str:
    """
    Search for national parks by state, park code, or query string.
    
    Args:
        state_code: Two-letter state code (e.g., 'CA', 'NY')
        park_code: Four-letter park code (e.g., 'yell', 'acad')
        query: Search query for park names or descriptions
        limit: Maximum number of results to return (default: 10)
    
    Returns:
        JSON string with park information including name, description, website, and location
    """
    # Log input parameters
    get_logger().debug(f"search_parks called with inputs: state_code={state_code}, park_code={park_code}, query={query}, limit={limit}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/parks"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        
        params = {"limit": str(limit)}
        if state_code:
            params["stateCode"] = state_code.upper()
        if park_code:
            params["parkCode"] = park_code.lower()
        if query:
            params["q"] = query

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            parks = []
            for park in data["data"]:
                park_info = {
                    "name": park.get("fullName", ""),
                    "code": park.get("parkCode", ""),
                    "description": park.get("description", ""),
                    "website": park.get("url", ""),
                    "states": park.get("states", ""),
                    "designation": park.get("designation", ""),
                    "latitude": park.get("latitude", ""),
                    "longitude": park.get("longitude", "")
                }
                parks.append(park_info)
            
            result = json.dumps({
                "total": data.get("total", len(parks)),
                "parks": parks
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"search_parks returning success result with {len(parks)} parks")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({"message": "No parks found matching your criteria"})
            get_logger().debug(f"search_parks returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"search_parks HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"search_parks returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"search_parks returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"search_parks request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"search_parks returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"search_parks unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"search_parks returning unexpected error: {result}")
        return result

@mcp.tool()
async def get_park_alerts(park_code: str) -> str:
    """
    Get current alerts for a specific national park.
    
    Args:
        park_code: Four-letter park code (e.g., 'yell', 'acad', 'grca')
    
    Returns:
        JSON string with current alerts for the park
    """
    # Log input parameters
    get_logger().debug(f"get_park_alerts called with inputs: park_code={park_code}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/alerts"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        params = {"parkCode": park_code.lower()}

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            alerts = []
            for alert in data["data"]:
                alert_info = {
                    "title": alert.get("title", ""),
                    "category": alert.get("category", ""),
                    "description": alert.get("description", ""),
                    "url": alert.get("url", ""),
                    "parkCode": alert.get("parkCode", "")
                }
                alerts.append(alert_info)
            
            result = json.dumps({
                "parkCode": park_code.upper(),
                "totalAlerts": len(alerts),
                "alerts": alerts
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"get_park_alerts returning success result with {len(alerts)} alerts")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({
                "parkCode": park_code.upper(),
                "message": "No current alerts for this park"
            })
            get_logger().debug(f"get_park_alerts returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"get_park_alerts HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"get_park_alerts returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_alerts returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"get_park_alerts request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_alerts returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"get_park_alerts unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_alerts returning unexpected error: {result}")
        return result

@mcp.tool()
async def get_park_campgrounds(park_code: str, limit: int = 10) -> str:
    """
    Get campground information for a specific national park.
    
    Args:
        park_code: Four-letter park code (e.g., 'yell', 'acad', 'grca')
        limit: Maximum number of campgrounds to return (default: 10)
    
    Returns:
        JSON string with campground information including location, amenities, and fees
    """
    # Log input parameters
    get_logger().debug(f"get_park_campgrounds called with inputs: park_code={park_code}, limit={limit}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/campgrounds"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        params = {"parkCode": park_code.lower(), "limit": str(limit)}

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            campgrounds = []
            for campground in data["data"]:
                campground_info = {
                    "name": campground.get("name", ""),
                    "description": campground.get("description", ""),
                    "latitude": campground.get("latitude", ""),
                    "longitude": campground.get("longitude", ""),
                    "reservationInfo": campground.get("reservationInfo", ""),
                    "reservationUrl": campground.get("reservationUrl", ""),
                    "regulationsUrl": campground.get("regulationsUrl", ""),
                    "parkCode": campground.get("parkCode", "")
                }
                campgrounds.append(campground_info)
            
            result = json.dumps({
                "parkCode": park_code.upper(),
                "totalCampgrounds": len(campgrounds),
                "campgrounds": campgrounds
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"get_park_campgrounds returning success result with {len(campgrounds)} campgrounds")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({
                "parkCode": park_code.upper(),
                "message": "No campgrounds found for this park"
            })
            get_logger().debug(f"get_park_campgrounds returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"get_park_campgrounds HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"get_park_campgrounds returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_campgrounds returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"get_park_campgrounds request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_campgrounds returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"get_park_campgrounds unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_campgrounds returning unexpected error: {result}")
        return result

@mcp.tool()
async def get_park_events(park_code: str, limit: int = 10) -> str:
    """
    Get upcoming events for a specific national park.
    
    Args:
        park_code: Four-letter park code (e.g., 'yell', 'acad', 'grca')
        limit: Maximum number of events to return (default: 10)
    
    Returns:
        JSON string with event information including date, time, fee, and description
    """
    # Log input parameters
    get_logger().debug(f"get_park_events called with inputs: park_code={park_code}, limit={limit}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/events"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        params = {"parkCode": park_code.lower(), "limit": str(limit)}

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            events = []
            for event in data["data"]:
                event_info = {
                    "title": event.get("title", ""),
                    "description": event.get("description", ""),
                    "location": event.get("location", ""),
                    "dateStart": event.get("dateStart", ""),
                    "dateEnd": event.get("dateEnd", ""),
                    "timeStart": event.get("timeStart", ""),
                    "timeEnd": event.get("timeEnd", ""),
                    "feeInfo": event.get("feeInfo", ""),
                    "isRecurring": event.get("isRecurring", False),
                    "parkCode": event.get("parkCode", "")
                }
                events.append(event_info)
            
            result = json.dumps({
                "parkCode": park_code.upper(),
                "totalEvents": len(events),
                "events": events
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"get_park_events returning success result with {len(events)} events")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({
                "parkCode": park_code.upper(),
                "message": "No upcoming events found for this park"
            })
            get_logger().debug(f"get_park_events returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"get_park_events HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"get_park_events returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_events returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"get_park_events request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_events returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"get_park_events unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_events returning unexpected error: {result}")
        return result

@mcp.tool()
async def get_visitor_centers(park_code: str, limit: int = 10) -> str:
    """
    Get visitor center information for a specific national park.
    
    Args:
        park_code: Four-letter park code (e.g., 'yell', 'acad', 'grca')
        limit: Maximum number of visitor centers to return (default: 10)
    
    Returns:
        JSON string with visitor center information including location, contact, and operating hours
    """
    # Log input parameters
    get_logger().debug(f"get_visitor_centers called with inputs: park_code={park_code}, limit={limit}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/visitorcenters"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        params = {"parkCode": park_code.lower(), "limit": str(limit)}

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            centers = []
            for center in data["data"]:
                center_info = {
                    "name": center.get("name", ""),
                    "description": center.get("description", ""),
                    "latitude": center.get("latitude", ""),
                    "longitude": center.get("longitude", ""),
                    "directionsInfo": center.get("directionsInfo", ""),
                    "directionsUrl": center.get("directionsUrl", ""),
                    "operatingHours": center.get("operatingHours", []),
                    "addresses": center.get("addresses", []),
                    "contacts": center.get("contacts", {}),
                    "parkCode": center.get("parkCode", "")
                }
                centers.append(center_info)
            
            result = json.dumps({
                "parkCode": park_code.upper(),
                "totalVisitorCenters": len(centers),
                "visitorCenters": centers
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"get_visitor_centers returning success result with {len(centers)} visitor centers")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({
                "parkCode": park_code.upper(),
                "message": "No visitor centers found for this park"
            })
            get_logger().debug(f"get_visitor_centers returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"get_visitor_centers HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"get_visitor_centers returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_visitor_centers returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"get_visitor_centers request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_visitor_centers returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"get_visitor_centers unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_visitor_centers returning unexpected error: {result}")
        return result

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="NPS MCP Server - Provides National Park Service information via MCP protocol",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Transport modes:
  stdio: Communication via stdin/stdout (default) - for local MCP clients
  sse:   Server-Sent Events HTTP server mode - for remote MCP clients

Environment Variables:
  NPS_API_KEY: Your NPS API key (get one at https://www.nps.gov/subjects/developer/get-started.htm)
               If not set, will use DEMO_KEY with limited functionality

Examples:
  python nps_mcp_server.py                    # Run with stdio (default, WARNING level)
  python nps_mcp_server.py --transport stdio  # Explicit stdio mode
  python nps_mcp_server.py --transport sse    # SSE HTTP server mode
  python nps_mcp_server.py --transport sse --port 8080  # Custom port
  python nps_mcp_server.py --transport sse --host 0.0.0.0  # Bind to all interfaces

  # With different logging levels (only affects this server, not dependencies)
  python nps_mcp_server.py --log-level DEBUG  # Enable debug logging for NPS server
  python nps_mcp_server.py --log-level INFO   # Info level and above for NPS server
  python nps_mcp_server.py -l ERROR          # Only errors and critical for NPS server

  # With API key
  NPS_API_KEY=your_api_key_here python nps_mcp_server.py
        """
    )
    
    parser.add_argument(
        "--transport", "-t",
        choices=["stdio", "sse"],
        default="stdio",
        help="Transport mode: stdio (default) or sse (HTTP-based)"
    )
    
    parser.add_argument(
        "--host",
        default="localhost", 
        help="Host to bind to in HTTP mode (default: localhost)"
    )
    
    parser.add_argument(
        "--port", "-p",
        type=int,
        default=3000,
        help="Port to bind to in HTTP mode (default: 3000)"
    )
    
    parser.add_argument(
        "--log-level", "-l",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        default="WARNING",
        help="Set the logging level (default: WARNING)"
    )
    
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_arguments()
    
    # Configure logging based on command line argument  
    configure_logging(args.log_level)
    
    # Test that our logger is working (only in DEBUG mode)
    if args.log_level == "DEBUG":
        get_logger().debug("NPS server logging initialized at DEBUG level")
        get_logger().info("Ready to log tool invocations and API calls")
    
    print("Starting MCP NPS Server...")
    print(f"Logging level: {args.log_level}")
    print("Available tools:")
    print("- search_parks: Search for national parks by state, park code, or query")
    print("- get_park_alerts: Get current alerts for a specific park")
    print("- get_park_campgrounds: Get campground information for a park")
    print("- get_park_events: Get upcoming events for a park")
    print("- get_visitor_centers: Get visitor center information for a park")
    
    # Check API key
    api_key = get_api_key()
    if api_key == "DEMO_KEY":
        print("\n⚠️  Using DEMO_KEY - limited functionality")
        print("   Get a free API key at: https://www.nps.gov/subjects/developer/get-started.htm")
        print("   Set it with: export NPS_API_KEY=your_api_key_here")
    else:
        print(f"\n✅ Using API key: {api_key[:3]}...")
    
    if args.transport == "stdio":
        print("\n🔗 Transport: STDIO")
        print("This server communicates via stdin/stdout.")
        print("Connect to it using an MCP client running as a subprocess.")
        print("\nExample usage from an agent:")
        print('  Agent(server_specs="nps_mcp_server.py")')
        
        # Using 'stdio' transport for local communication with a client running as a subprocess
        mcp.run(transport="stdio")
        
    elif args.transport == "sse":
        print("\n🌐 Transport: SSE (HTTP-based)")
        print(f"Server will be available at: http://{args.host}:{args.port}")
        print("Connect to it using a remote MCP client.")
        print("\nExample usage from an agent:")
        print(f'  Agent(server_specs="remote:http://{args.host}:{args.port}")')
        print("\nExample test commands:")
        print("  # Test the remote server")
        print(f"  python openai_mcp_agent.py --server remote:http://{args.host}:{args.port}")
        print("\n🚀 Starting SSE server...")
        
        # Using 'sse' transport for remote communication
        # The newer FastMCP library supports host and port parameters
        try:
            mcp.run(transport="sse", host=args.host, port=args.port)
        except Exception as e:
            print(f"Error starting SSE server: {e}")
            if "address already in use" in str(e).lower() or "errno 48" in str(e).lower():
                print(f"\n💡 Port {args.port} is already in use. Try:")
                print(f"  1. Check what's using port {args.port}: lsof -i :{args.port}")
                print("  2. Kill the existing process: kill <PID>")
                print("  3. Try a different port: python nps_mcp_server.py --transport sse --port <different_port>")
                print("  4. Or use stdio mode: python nps_mcp_server.py --transport stdio")
            else:
                print("Please check the error message above and try again.")
    
    print("\nServer stopped.")

